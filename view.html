<html>
	<head>
		<title>My first Three.js app</title>
		<style>canvas { width: 100%; height: 100% }</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			var geometry = new THREE.BoxGeometry(1,1,1);
			
			// LIGHT
			var light = new THREE.PointLight(0xaaaaff);
			light.position.set(-100,100,100);
			scene.add(light);
			var light = new THREE.PointLight(0xffddaa);
			light.position.set(100,100,-100);
			scene.add(light);
			var light = new THREE.AmbientLight(0x222222);
			scene.add(light);

			camera.position.z = 5;
			camera.position.y = 8;
			camera.position.x = 0;
			camera.lookAt(new THREE.Vector3(0,0,0));

			var input = "1,9,7,11,10,3,6,14,5,15,12,8,13,2,4,16".split(")").join("").split("(").join("").split(" ").join("").split(",");
			var weight = [112,104,92,112,146,58,84,122,88,76,90,114,112,110,110,154];

			var weightedInput = input.map(function(val, i) { return val * weight[i];});

			var maxWeight = Math.max.apply(null, weight);
			var maxInput = Math.max.apply(null, input);
			var maxWeightedInput = Math.max.apply(null, weightedInput);
			var heightScale = 4 / maxInput;
			var weightedHeightScale = 4 / maxWeightedInput;
			var colorScale = 255 / maxWeightedInput;
			var cs = 255 / maxWeight;

			var cubes = [];
			var gap = 1.1;
			var group = new THREE.Object3D();
			scene.add(group);
			var size = input.length;
			var width = Math.sqrt(size);
			var offset = -(width / 2) * gap + 0.5;
			for (var i = 0; i < size; i++) {
				var material = new THREE.MeshLambertMaterial({color: (Math.round(weightedInput[i] * colorScale)<<16) + 0xFFFF});
				var cube = new THREE.Mesh(geometry, material);
				group.add(cube);
				cube.position.x = offset + i % width * gap;
				// cube.scale.y = input[i] * 0.1;
				cube.scale.y = weightedInput[i] * weightedHeightScale;
				cube.position.y = cube.scale.y * 0.5;
				cube.position.z = offset + Math.floor(i / width) * gap;
				cubes[i] = cube;
			};

			var originalGroup = new THREE.Object3D();
			scene.add(originalGroup);
			for (var i = 0; i < size; i++) {
				var material = new THREE.MeshLambertMaterial({color: 0xFFFF00 + Math.round(weight[i] * cs)});
				var cube = new THREE.Mesh(geometry, material);
				originalGroup.add(cube);
				cube.position.x = offset + i % width * gap;
				cube.scale.y = input[i] * heightScale;
				// cube.scale.y = input[i] * heightScale;
				cube.position.y = cube.scale.y * 0.5;
				cube.position.z = offset + Math.floor(i / width) * gap;
			};

			originalGroup.position.x = size/4;
			group.position.x = -size/4;

			var render = function () {
				requestAnimationFrame(render);

				group.rotation.y += 0.01;
				originalGroup.rotation.y += 0.01;

				renderer.render(scene, camera);
			};

			render();
		</script>
	</body>
</html>